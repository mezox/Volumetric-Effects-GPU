/*	Brief:			Projection compute shader
 *	Description:	Pressure projection to velocity using gradient substraction
 */

#version 450

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

uniform float gradientScale;

// inputs
layout (binding = 0) uniform sampler3D velocity;
layout (binding = 1) uniform sampler3D obstacle;
layout (binding = 2) uniform sampler3D pressure;

//outputs
layout (binding = 0, rgba16f) uniform image3D velocityImage;

ivec3 clampImage (ivec3 position)
{
	ivec3 result;
	result.x = clamp(position.x, 0, int(gl_NumWorkGroups.x * gl_WorkGroupSize.x) -1);
	result.y = clamp(position.y, 0, int(gl_NumWorkGroups.y * gl_WorkGroupSize.y) -1);
	result.z = clamp(position.z, 0, int(gl_NumWorkGroups.z * gl_WorkGroupSize.z) -1);
	return result;
}

void main()
{
	ivec3 position = ivec3(gl_GlobalInvocationID);
	vec4 finalVelocity;
	
	// Velocity is zero if current cell is solid
	if(texelFetch(obstacle, position, 0).x > 0)
	{
		finalVelocity.xyz = vec3(0);
	}
	else
	{
		// Get pressure values for the current cell and its neighbors.
		float pressureForward	= texelFetch(pressure, clampImage(position +ivec3(0, 0, 1)), 0).x;
		float pressureBackward	= texelFetch(pressure, clampImage(position +ivec3(0, 0, -1)), 0).x;
		float pressureRight		= texelFetch(pressure, clampImage(position +ivec3(1, 0, 0)), 0).x;
		float pressureLeft		= texelFetch(pressure, clampImage(position +ivec3(-1, 0, 0)), 0).x;
		float pressureUp		= texelFetch(pressure, clampImage(position +ivec3(0, 1, 0)), 0).x;
		float pressureDown		= texelFetch(pressure, clampImage(position +ivec3(0, -1, 0)), 0).x;
		float pressureCenter	= texelFetch(pressure, position, 0).x;
		
		// Get obstacle velocities in neighboring solid cells.
		// (Note that these values are meaningless if a neighbor
		// is not solid.)
		vec4 obstacleForward	= texelFetch(obstacle, clampImage(position +ivec3(0, 0, 1)), 0);
		vec4 obstacleBackward	= texelFetch(obstacle, clampImage(position +ivec3(0, 0, -1)), 0);
		vec4 obstacleRight		= texelFetch(obstacle, clampImage(position +ivec3(1, 0, 0)), 0);
		vec4 obstacleLeft		= texelFetch(obstacle, clampImage(position +ivec3(-1, 0, 0)), 0);
		vec4 obstacleUp			= texelFetch(obstacle, clampImage(position +ivec3(0, 1, 0)), 0);
		vec4 obstacleDown		= texelFetch(obstacle, clampImage(position +ivec3(0, -1, 0)), 0);
		
		vec3 obstacleVelocity = vec3(0);
		vec3 velocityMask = vec3(1);
		
		// If an adjacent cell is solid, ignore its pressure and use its velocity.
		// (I'm only using static obstacles so obstacle velocity is never used)
		if (obstacleForward.x > 0)	{	pressureForward		= pressureCenter; obstacleVelocity.z = obstacleForward.z;	velocityMask.z = 0;}
		if (obstacleBackward.x > 0)	{	pressureBackward	= pressureCenter; obstacleVelocity.z = obstacleBackward.z;	velocityMask.z = 0;}
		if (obstacleRight.x > 0)	{	pressureRight		= pressureCenter; obstacleVelocity.x = obstacleLeft.x;		velocityMask.x = 0;}
		if (obstacleLeft.x > 0)		{	pressureLeft		= pressureCenter; obstacleVelocity.x = obstacleRight.x;		velocityMask.x = 0;}
		if (obstacleUp.x > 0)		{	pressureUp			= pressureCenter; obstacleVelocity.y = obstacleUp.y;		velocityMask.y = 0;}
		if (obstacleDown.x > 0)		{	pressureDown		= pressureCenter; obstacleVelocity.y = obstacleDown.y;		velocityMask.y = 0;}
		
		// Explicitly enforce the free-slip boundary condition by
		// replacing the appropriate components of the new velocity with
		// obstacle velocities.
		vec3 previousVelocity = texelFetch(velocity, position, 0).xyz;
		vec3 grad = vec3(	pressureRight - pressureLeft,
							pressureUp - pressureDown,
							pressureForward - pressureBackward) * 0.5;
		vec3 v = previousVelocity - grad * gradientScale;
		finalVelocity.xyz = (v * velocityMask) + obstacleVelocity;
	}

	imageStore(velocityImage, position, finalVelocity);
}